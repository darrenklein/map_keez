# MapKeez

Convert map keys from atom to string or string to atom.

## Installation

## Use

**MapKeez** provides three methods for converting the keys of a map between strings and atoms. By default, only the top-level keys of a map will be converted, and struct keys will not be converted - however, these behaviors can both be modified using the options found under the [Options](#options) section below.

#### `to_string_keys/2`

Convert top-level atom keys to string keys.

```elixir
(1)> map = %{foo: "bar", baz: "bim"}
%{baz: "bim", foo: "bar"}

(2)> map |> MapKeez.to_string_keys()
%{"baz" => "bim", "foo" => "bar"}
```

#### `to_atom_keys!/2`

Safely convert top-level string keys to atom keys by way of `String.to_existing_atom()`. This method will raise an `Argument` error if any keys cannot be successfully converted. If you need to convert keys to atoms, this is probably your best bet - if you're not familiar with why this is, see [this article](https://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion.html) on atom exhaustion.

```elixir
(1)> map = %{"foo" => "bar", "baz" => "bim"}
%{"baz" => "bim", "foo" => "bar"}

(2)> map |> MapKeez.to_atom_keys!()
** (ArgumentError) errors were found at the given arguments:

  * 1st argument: invalid UTF8 encoding
```

```elixir
(1)> _safe_atoms = [:foo, :baz]
[:foo, :baz]

(2)> map = %{"foo" => "bar", "baz" => "bim"}
%{"baz" => "bim", "foo" => "bar"}

(3)> map |> MapKeez.to_atom_keys!()
%{baz: "bim", foo: "bar"}
```

#### `to_atom_keys_unsafe/2`

As the name implies, unsafely convert top-level string keys to atom keys by way of `String.to_atom()`. In generaly, you should prefer `to_atom_keys!/2` unless it's simply not a viable option and/or you are confident that you won't risk exhausting your atom table by doing something like converting a map whose keys were generated by arbitrary user input.

```elixir
(1)> map = %{"foo" => "bar", "baz" => %{"moo" => "mar}}
%{"baz" => "bim", "foo" => %{"moo" => "mar"}}

(2)> map |> MapKeez.to_atom_keys_unsafe()
%{baz: "bim", foo: %{"moo" => "mar"}}
```

### Options

`recursive :: boolean - default: false`

The default behavior of **MapKeez**'s methods is to convert top-level map keys. If you have a nested structure for which you need to convert all map keys that occur within that structure, use the `recursive: true` option. This option will recurse through any nested maps or lists (but not structs - see `convert_structs` option below), converting any map keys found along the way.

```elixir
(1)> map = %{foo: "bar", baz: [%{bim: "bang", moo: %{mar: [%{"maz" => "ming"}, %{mong: "moon"}]}}]}
%{
  baz: [%{bim: "bang", moo: %{mar: [%{"maz" => "ming"}, %{mong: "moon"}]}}],
  foo: "bar"
}

(2)> map |> MapKeez.to_string_keys([recursive: true])
%{
  "baz" => [
    %{
      "bim" => "bang",
      "moo" => %{"mar" => [%{"maz" => "ming"}, %{"mong" => "moon"}]}
    }
  ],
  "foo" => "bar"
}
```

`convert_structs :: boolean - default: false`

When encountering a struct, the default behavior of **MapKeez** is to avoid altering the struct or its contents in any way - this applies even in cases where `recursive` is set to `true`. If you wish to convert the keys of structs, set the `convert_structs` option to `true`. **Beware that setting this option to `true` will result in the conversion of structs to maps, even in cases where keys are being converted to atoms.**

```elixir
(1)> %MapKeezTest.Assets.TestStruct{}
%MapKeezTest.Assets.TestStruct{
  atom_key_attributes: %{eye_color: "purple"},
  name: "Bob",
  string_key_attributes: %{"height" => 10}
}

(2)> %MapKeezTest.Assets.TestStruct{} |> MapKeez.to_string_keys([convert_structs: true])
%{
  "atom_key_attributes" => %{eye_color: "purple"},
  "name" => "Bob",
  "string_key_attributes" => %{"height" => 10}
}

(3)> %MapKeezTest.Assets.TestStruct{} |> MapKeez.to_atom_keys!([convert_structs: true])
%{
  atom_key_attributes: %{eye_color: "purple"},
  name: "Bob",
  string_key_attributes: %{"height" => 10}
}

(4)> %MapKeezTest.Assets.TestStruct{} |> MapKeez.to_string_keys([convert_structs: true, recursive: true])
%{
  "atom_key_attributes" => %{"eye_color" => "purple"},
  "name" => "Bob",
  "string_key_attributes" => %{"height" => 10}
}

(5)> %MapKeezTest.Assets.TestStruct{} |> MapKeez.to_atom_keys_unsafe([convert_structs: true, recursive: true])
%{
  atom_key_attributes: %{eye_color: "purple"},
  name: "Bob",
  string_key_attributes: %{height: 10}
}
```

## Caveats

#### Atom 255 character name length limit

If you are converting string keys to atom keys via `to_atom_keys_unsafe/2`, be aware that you will be constrained by Erlang's maximum atom name length of 255 characters see [the docs](http://erlang.org/documentation/doc-5.8.4/doc/efficiency_guide/advanced.html) for reference. Violating this constraint will raise a `SystemLimitError`. Because of this, as well as the limited (though vast) capacity of the atom table, you should generally prefer `to_atom_keys!/2`.

#### Mixed key types with duplicate names

Elixir will allow you to create maps with mixed key types at the same level. This means that it is possible to have multiple keys with the same name. Using **MapKeez** in such cases is not recommended, as one key will end up being overridden and results may be difficult to predict. For example,

```elixir
(1)> map = %{"foo" => "bar", foo: "mar"}
%{:foo => "mar", "foo" => "bar"}
iex(5)> map |> MapKeez.to_string_keys()
%{"foo" => "bar"}
```

#### :convert_structs option converts structs to maps

This was mentioned earlier in the README, but it warrants reiterating - passing the `convert_structs: true` option will have the affect of converting any encountered structs to a map.
